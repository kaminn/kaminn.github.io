<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic|Monaco:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"kaminn.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":-1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="OverviewCMU 15-445 Fall 2021的课程期间需要完成一个基于磁盘的数据库Bustub，而这是其第一个Project（跳过了Project 0），其目标是构建一个Buffer Pool，Buffer Pool负责将物理页面从内存和磁盘之间进行换进换出。DBMS中执行引擎需要用到某页时，并非之间从磁盘中读取，而是从Buffer Pool中获取该页，由Buffer Pool负责页面">
<meta property="og:type" content="article">
<meta property="og:title" content="CMU 15-445 Project 1 Buffer Pool">
<meta property="og:url" content="https://kaminn.github.io/2022/05/02/CMU-15-445-Project-1-Buffer-Pool/">
<meta property="og:site_name" content="kaminn&#39;s blog">
<meta property="og:description" content="OverviewCMU 15-445 Fall 2021的课程期间需要完成一个基于磁盘的数据库Bustub，而这是其第一个Project（跳过了Project 0），其目标是构建一个Buffer Pool，Buffer Pool负责将物理页面从内存和磁盘之间进行换进换出。DBMS中执行引擎需要用到某页时，并非之间从磁盘中读取，而是从Buffer Pool中获取该页，由Buffer Pool负责页面">
<meta property="og:locale">
<meta property="og:image" content="https://images-1253386616.cos.ap-guangzhou.myqcloud.com/image-20220502223257589.png">
<meta property="og:image" content="https://images-1253386616.cos.ap-guangzhou.myqcloud.com/image-20220502232335875.png">
<meta property="og:image" content="https://images-1253386616.cos.ap-guangzhou.myqcloud.com/buffer%20pool.png">
<meta property="og:image" content="https://images-1253386616.cos.ap-guangzhou.myqcloud.com/frame%20status.png">
<meta property="og:image" content="https://images-1253386616.cos.ap-guangzhou.myqcloud.com/new%20page.png">
<meta property="og:image" content="https://images-1253386616.cos.ap-guangzhou.myqcloud.com/fetch%20page.png">
<meta property="og:image" content="https://images-1253386616.cos.ap-guangzhou.myqcloud.com/delete%20page.png">
<meta property="og:image" content="https://images-1253386616.cos.ap-guangzhou.myqcloud.com/unpin%20page.png">
<meta property="og:image" content="https://images-1253386616.cos.ap-guangzhou.myqcloud.com/image-20220503002900620.png">
<meta property="article:published_time" content="2022-05-02T11:26:10.000Z">
<meta property="article:modified_time" content="2022-05-03T17:30:10.918Z">
<meta property="article:author" content="kaminn">
<meta property="article:tag" content="数据库">
<meta property="article:tag" content="公开课">
<meta property="article:tag" content="CMU 15-445">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://images-1253386616.cos.ap-guangzhou.myqcloud.com/image-20220502223257589.png">

<link rel="canonical" href="https://kaminn.github.io/2022/05/02/CMU-15-445-Project-1-Buffer-Pool/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title>CMU 15-445 Project 1 Buffer Pool | kaminn's blog</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?8a557a660dfb6d4d8e2a3376ccdae50c";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">kaminn's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/kaminn" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://kaminn.github.io/2022/05/02/CMU-15-445-Project-1-Buffer-Pool/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="kaminn">
      <meta itemprop="description" content="从来也没有什么救世主，也不靠神仙皇帝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kaminn's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          CMU 15-445 Project 1 Buffer Pool
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-02 19:26:10" itemprop="dateCreated datePublished" datetime="2022-05-02T19:26:10+08:00">2022-05-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%AC%E5%BC%80%E8%AF%BE/" itemprop="url" rel="index"><span itemprop="name">公开课</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><p>CMU 15-445 Fall 2021的课程期间需要完成一个基于磁盘的数据库Bustub，而这是其第一个Project（跳过了Project 0），其目标是构建一个Buffer Pool，Buffer Pool负责将物理页面从内存和磁盘之间进行换进换出。DBMS中执行引擎需要用到某页时，并非之间从磁盘中读取，而是从Buffer Pool中获取该页，由Buffer Pool负责页面的获取、淘汰。</p>
<p><img src="https://images-1253386616.cos.ap-guangzhou.myqcloud.com/image-20220502223257589.png" alt="磁盘、Buffer Pool和执行引擎"></p>
<span id="more"></span>

<p>Buffer Pool内部维护一个固定大小的frame数组，记录Buffer Pool中缓存的页，还有一个page table用于记录page id与frame之间的关系。具体的Buffer Pool还需要通过具体的策略控制页面的淘汰，记录每个页面的使用情况以实现线程安全的控制、数据的安全等。</p>
<p>虽然看上去Buffer Pool的实现有些复杂，但是Project已经帮我们拆解好了任务，我们可以通过进行页面淘汰策略和页的管理两个方面的工作来实现Buffer Pool，具体到Project中分为以下三个任务:</p>
<ul>
<li><p><strong>LRU Replacement Policy</strong></p>
</li>
<li><p><strong>Buffer Pool Manager Instance</strong></p>
</li>
<li><p><strong>Parallel Buffer Pool Manager</strong></p>
</li>
</ul>
<p>因为我学习的时候其实时看的2019年的课程视频，所以我还额外完成了19年的Project1中有的<code>Clock Replacement Policy</code></p>
<h1 id="Clock-Replacement-Policy"><a href="#Clock-Replacement-Policy" class="headerlink" title="Clock Replacement Policy"></a>Clock Replacement Policy</h1><p>Clock Replacement Policy是一种近似LRU的淘汰策略，它通过将页组织成一个环进行扫描，每个页上有一个reference bit用于记录该页是否被访问过，如果页面被访问则reference bit设为1，否则为0。</p>
<p>每次扫描时，如果页面的reference bit为1，说明页面自上次扫描之后有过访问，则仅将reference bit设为0不进行淘汰；如果reference bit设为0，说明页面自上次扫描之后还没有被访问过，就可以将页面进行淘汰了。</p>
<p><img src="https://images-1253386616.cos.ap-guangzhou.myqcloud.com/image-20220502232335875.png" alt="Clock Replacement Policy描述"></p>
<p>我们需要实现一个<code>ClockReplacer</code>，代码框架已经给出，需要按照给定的框架实现<code>Replacer</code>接口:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 调用Victim方法表示需要淘汰一个Replacer中最近最少使用的frame，如果成功淘汰了这样的frame，将其frame id存储到frame_id中并返回true，</span></span><br><span class="line"><span class="comment"> * 否则返回false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Victim</span><span class="params">(<span class="type">frame_id_t</span> *frame_id)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 调用Pin方法表示Buffer Pool需要使用该frame，将该frame从Replacer中删除</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Pin</span><span class="params">(<span class="type">frame_id_t</span> frame_id)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 调用Unpin方法表示该frame没有线程在使用了，需要加入Replacer等待淘汰</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Unpin</span><span class="params">(<span class="type">frame_id_t</span> frame_id)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 返回Replacer的大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">Size</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>ClockReplacer</code>的实现比较简单，需要注意记录<code>clock_hand</code>也就是当前扫描的clock位置、clock是否存在以及是否被访问，然后根据算法描述去更新这些信息就好了，注意加锁保证线程安全。</p>
<h1 id="LRU-Replacement-Policy"><a href="#LRU-Replacement-Policy" class="headerlink" title="LRU Replacement Policy"></a>LRU Replacement Policy</h1><p>LRU应该很熟悉了，最近最少使用淘汰，可以看下<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lru-cache/">146. LRU 缓存 - LeetCode</a>。在Project中，我们需要实现一个<code>LRUReplacer</code>，还是按照上面的<code>Replacer</code>接口，这个接口和LeetCode上的get、put等还不太一样。</p>
<p>这里的<code>LRUReplacer</code>中记录的是可以被淘汰的页，而不是全部的页。Pin的过程是从<code>LRUReplacer</code>中删除该页面，这样该页面就不会被淘汰了。Unpin则是在<code>LRUReplacer</code>中加入该页面，这样该页面就可能被淘汰。</p>
<p><code>LRUReplacer</code>我们还是通过hashmap+双向链表的形式来实现，链表中存储<code>frame_id</code>，每次将最近访问过的<code>frame_id</code>添加到链表头部，每次淘汰<code>frame_id</code>从链表尾部开始淘汰。hashmap中存储<code>frame_id</code>以及<code>frame_id</code>在链表中的位置，用于实现以O(1)时间复杂度获取到<code>frame_id</code>。具体的实现如下:</p>
<h2 id="bool-Victim-frame-id-t-frame-id"><a href="#bool-Victim-frame-id-t-frame-id" class="headerlink" title="bool Victim(frame_id_t *frame_id)"></a>bool Victim(frame_id_t *frame_id)</h2><p>只要链表不为空，则从链表尾部淘汰一个<code>frame_id</code>返回，删除hashmap中对应的<code>frame_id</code>，并返回true，否则返回false。</p>
<h2 id="void-Pin-frame-id-t-frame-id"><a href="#void-Pin-frame-id-t-frame-id" class="headerlink" title="void Pin(frame_id_t frame_id)"></a>void Pin(frame_id_t frame_id)</h2><p>在hashmap中找到<code>frame_id</code>，直接将该frame从hashmap和链表中都删除。</p>
<h2 id="void-Unpin-frame-id-t-frame-id"><a href="#void-Unpin-frame-id-t-frame-id" class="headerlink" title="void Unpin(frame_id_t frame_id)"></a>void Unpin(frame_id_t frame_id)</h2><p>当<code>frame_id</code>不在hashmap中且链表还未满时，把<code>frame_id</code>插入链表头部，hashmap记录<code>frame_id</code>在链表中的位置。</p>
<h2 id="size-t-Size"><a href="#size-t-Size" class="headerlink" title="size_t Size()"></a>size_t Size()</h2><p>直接返回链表的size。</p>
<p>以上的实现也要注意加锁保证线程安全。</p>
<h1 id="Buffer-Pool-Manager-Instance"><a href="#Buffer-Pool-Manager-Instance" class="headerlink" title="Buffer Pool Manager Instance"></a>Buffer Pool Manager Instance</h1><p><code>BufferPoolManagerInstance</code>即是管理Buffer Pool的实体，负责从<code>DiskManager</code>获取页面并将它们存储在内存中。 <code>BufferPoolManagerInstance</code>也可以将脏页写回磁盘以持久化数据变更。</p>
<p>在内存中，数据库页总是以<code>Page</code>对象来表示，在系统的整个生命周期中，相同的<code>Page</code>对象可能包含不同的物理页面，<code>Page</code>对象中我们需要关心的属性有:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** page对象实际存储的数据 */</span></span><br><span class="line"><span class="type">char</span> data_[PAGE_SIZE]&#123;&#125;;</span><br><span class="line"><span class="comment">/** page id */</span></span><br><span class="line"><span class="type">page_id_t</span> page_id_ = INVALID_PAGE_ID;</span><br><span class="line"><span class="comment">/** 表示page被多少线程使用，引用计数*/</span></span><br><span class="line"><span class="type">int</span> pin_count_ = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/** 该page是否为脏页 */</span></span><br><span class="line"><span class="type">bool</span> is_dirty_ = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p><code>BufferPoolManagerInstance</code>中我们需要关心的属性有:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** page数组基地址，pages_+frame_id就可以定位到一个page对象 */</span></span><br><span class="line">Page *pages_;</span><br><span class="line"><span class="comment">/** page table，记录page_id与frame_id之间的映射关系 */</span></span><br><span class="line">std::unordered_map&lt;<span class="type">page_id_t</span>, <span class="type">frame_id_t</span>&gt; page_table_;</span><br><span class="line"><span class="comment">/** 负责淘汰页面，这里我们都使用LRUReplacer */</span></span><br><span class="line">Replacer *replacer_;</span><br><span class="line"><span class="comment">/** 空闲frame_id列表 */</span></span><br><span class="line">std::list&lt;<span class="type">frame_id_t</span>&gt; free_list_;</span><br></pre></td></tr></table></figure>

<p><code>BufferPoolManagerInstance</code>中我们需要实现的接口有:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 从Buffer Pool中获取一个页面</span></span><br><span class="line"><span class="comment">   * @param page_id 需要获取的页的page id</span></span><br><span class="line"><span class="comment">   * @return 获取到的页面</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="function">Page *<span class="title">FetchPgImp</span><span class="params">(<span class="type">page_id_t</span> page_id)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 从Buffer Pool中unpin一个页面</span></span><br><span class="line"><span class="comment">   * @param page_id 需要unpin的page id</span></span><br><span class="line"><span class="comment">   * @param is_dirty 是否需要标记该页为脏页</span></span><br><span class="line"><span class="comment">   * @return 如果该页面的pin count在调用前已经小于等于0了就返回false，否则返回true</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">UnpinPgImp</span><span class="params">(<span class="type">page_id_t</span> page_id, <span class="type">bool</span> is_dirty)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 将Buffer Pool中的指定页面写回磁盘</span></span><br><span class="line"><span class="comment">   * @param page_id id 需要写回的page id，不能是INVALID_PAGE_ID</span></span><br><span class="line"><span class="comment">   * @return 如果页面在page table中不存在则返回false，否则返回true</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">FlushPgImp</span><span class="params">(<span class="type">page_id_t</span> page_id)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 创建一个新的页面</span></span><br><span class="line"><span class="comment">   * @param[out] page_id 新页面的page id写入这个参数</span></span><br><span class="line"><span class="comment">   * @return 创建成功返回新创建的页的指针，否则返回null</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="function">Page *<span class="title">NewPgImp</span><span class="params">(<span class="type">page_id_t</span> *page_id)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 从Buffer Pool中删除一个页</span></span><br><span class="line"><span class="comment">   * @param page_id 待删除的页的page id</span></span><br><span class="line"><span class="comment">   * @return 删除成功返回true，失败返回false</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DeletePgImp</span><span class="params">(<span class="type">page_id_t</span> page_id)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 把Buffer Pool中缓存的所有页面都写回磁盘</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FlushAllPgsImp</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>Buffer Pool、Replacer和Disk Manager的交互逻辑如下:</p>
<p><img src="https://images-1253386616.cos.ap-guangzhou.myqcloud.com/buffer%20pool.png" alt="buffer pool"></p>
<p>Replacer类似于一个页面回收站，维护了没有线程使用的可以被清除的frame的<code>frame_id</code>，Buffer Pool每次使用完一个页面时调用<code>UnpinPgImp</code>将页面放入回收站，在需要获取页面时可以从回收站获取可以被复用的frame的<code>frame_id</code>。Buffer Pool从磁盘读取页面数据通过调用Disk Manager的<code>ReadPage</code>方法实现，Buffer Pool将内存页面数据写回磁盘通过调用Disk Manager的<code>WritePage</code>方法实现。</p>
<p>frame在Buffer Pool和Replacer之间流转，一共有三种状态，分别是free、pinned和unpinned，frame的状态流转如下:</p>
<p><img src="https://images-1253386616.cos.ap-guangzhou.myqcloud.com/frame%20status.png" alt="frame status"></p>
<p>具体来讲一讲每个接口的实现逻辑和需要注意的细节:</p>
<h2 id="Page-BufferPoolManagerInstance-NewPgImp-page-id-t-page-id"><a href="#Page-BufferPoolManagerInstance-NewPgImp-page-id-t-page-id" class="headerlink" title="Page *BufferPoolManagerInstance::NewPgImp(page_id_t *page_id)"></a>Page *BufferPoolManagerInstance::NewPgImp(page_id_t *page_id)</h2><p>给出的代码中已有详细的逻辑注释，方法执行逻辑流程如下:</p>
<p><img src="https://images-1253386616.cos.ap-guangzhou.myqcloud.com/new%20page.png" alt="new page"></p>
<p>需要注意的几个点是:</p>
<ul>
<li>先尝试从<code>free_list_</code>中获取空闲的frame，如果没有空闲的frame再尝试从<code>Replacer</code>获取一个淘汰的frame。</li>
<li>从<code>Replacer</code>中获取的淘汰的frame，一定要检查是否为脏页，如果为脏页需要先把先前的数据写回磁盘，以免脏页数据丢失。</li>
<li>从<code>Replacer</code>中获取的淘汰的frame，需要从<code>page_table_</code>中删除这个frame之前的<code>page_id_</code>与<code>frame_id</code>的映射。后面再用新的<code>page_id</code>映射<code>frame_id</code>。</li>
</ul>
<h2 id="Page-BufferPoolManagerInstance-FetchPgImp-page-id-t-page-id"><a href="#Page-BufferPoolManagerInstance-FetchPgImp-page-id-t-page-id" class="headerlink" title="Page *BufferPoolManagerInstance::FetchPgImp(page_id_t page_id)"></a>Page *BufferPoolManagerInstance::FetchPgImp(page_id_t page_id)</h2><p>请求指定<code>page_id</code>的内容，返回<code>page</code>指针，同样在给出的代码框架中已有详细的逻辑注释了，逻辑流程如下:</p>
<p><img src="https://images-1253386616.cos.ap-guangzhou.myqcloud.com/fetch%20page.png" alt="fetch page"></p>
<p>需要注意的点:</p>
<ul>
<li>如果<code>page_table_</code>中能找到对应的<code>page_id</code>，则可以不用读磁盘，直接返回对应的<code>page</code>指针。</li>
<li>如果<code>page_table_</code>中能找到对应的<code>page_id</code>，返回对应<code>page</code>指针之前，需要调用<code>replacer_</code>的<code>Pin</code>方法把对应的frame从回收站拿出来，<code>pin_count_</code>++。</li>
<li>更新<code>page</code>的metadata时，记得pin_count_++，表示线程正在使用这个页。</li>
</ul>
<h2 id="bool-BufferPoolManagerInstance-FlushPgImp-page-id-t-page-id"><a href="#bool-BufferPoolManagerInstance-FlushPgImp-page-id-t-page-id" class="headerlink" title="bool BufferPoolManagerInstance::FlushPgImp(page_id_t page_id)"></a>bool BufferPoolManagerInstance::FlushPgImp(page_id_t page_id)</h2><p><code>FlushPgImp</code>主要操作就是调用<code>disk_manager_</code>的<code>WritePage</code>方法将页的内容写回磁盘，逻辑比较简单，只要<code>page_id</code>不等于<code>INVALID_PAGE_ID</code>即-1，且<code>page_table_</code>中存在对应<code>page_id</code>，就将页内容写回磁盘，顺便将页的<code>is_dirty_</code>置为false。</p>
<h2 id="void-BufferPoolManagerInstance-FlushAllPgsImp"><a href="#void-BufferPoolManagerInstance-FlushAllPgsImp" class="headerlink" title="void BufferPoolManagerInstance::FlushAllPgsImp()"></a>void BufferPoolManagerInstance::FlushAllPgsImp()</h2><p>这个接口的实现也比较简单，就是遍历<code>page_table_</code>，将里面的页的内容全部写回到磁盘，顺便将页的<code>is_dirty_</code>置为false。</p>
<h2 id="bool-BufferPoolManagerInstance-DeletePgImp-page-id-t-page-id"><a href="#bool-BufferPoolManagerInstance-DeletePgImp-page-id-t-page-id" class="headerlink" title="bool BufferPoolManagerInstance::DeletePgImp(page_id_t page_id)"></a>bool BufferPoolManagerInstance::DeletePgImp(page_id_t page_id)</h2><p>这个接口可以直接删除Buffer Pool中的一个页，不用等<code>replacer_</code>去淘汰这个页。</p>
<p>具体的逻辑流程如下:</p>
<p><img src="https://images-1253386616.cos.ap-guangzhou.myqcloud.com/delete%20page.png" alt="delete page"></p>
<p>需要注意的点:</p>
<ul>
<li>只有<code>pin_count_</code>不为0时才返回false，其余情况都是返回true，<code>page_table_</code>中找不到<code>page_id</code>时也返回true，这个注释里有说。</li>
<li>这里是直接删除页面，所以不用再调用<code>replacer_</code>的<code>Unpin</code>方法把frame加入到回收站再等待淘汰，删除页面后的<code>frame_id</code>直接加入<code>free_list_</code>。</li>
</ul>
<h2 id="bool-BufferPoolManagerInstance-UnpinPgImp-page-id-t-page-id-bool-is-dirty"><a href="#bool-BufferPoolManagerInstance-UnpinPgImp-page-id-t-page-id-bool-is-dirty" class="headerlink" title="bool BufferPoolManagerInstance::UnpinPgImp(page_id_t page_id, bool is_dirty)"></a>bool BufferPoolManagerInstance::UnpinPgImp(page_id_t page_id, bool is_dirty)</h2><p>这个接口代码中没有给出太多的注释，不过经过上面的状态流转分析以及数据流分析等，这个方法的逻辑应该也比较清楚，具体的逻辑流程如下:</p>
<p><img src="https://images-1253386616.cos.ap-guangzhou.myqcloud.com/unpin%20page.png" alt="unpin page"></p>
<p>需要注意的点:</p>
<ul>
<li>只有调用时<code>pin_count_</code>已经小于等于0才返回false，其余情况都是返回true，<code>page_table_</code>中找不到<code>page_id</code>时也返回true，这个注释里有说。</li>
<li>不能直接将<code>page</code>的<code>is_dirty_</code>属性直接更新成参数<code>is_dirty</code>的值，因为可能出现<code>page</code>本身已经是脏页但是<code>is_dirty</code>给的是false，就有可能丢失数据。</li>
<li>只有<code>pin_count_</code>-1后为0时，才需要调用<code>replacer_</code>的<code>Unpin</code>方法。</li>
</ul>
<p>所有的接口都要记得加锁来保证线程安全。</p>
<h1 id="Parallel-Buffer-Pool-Manager"><a href="#Parallel-Buffer-Pool-Manager" class="headerlink" title="Parallel Buffer Pool Manager"></a>Parallel Buffer Pool Manager</h1><p>这是一个并行Buffer Pool管理器，内部管理着多个<code>BufferPoolManagerInstance</code>，对外暴露和<code>BufferPoolManagerInstance</code>同样的接口（它们都实现了<code>BufferPoolManager</code>接口）。</p>
<p><code>ParallelBufferPoolManager</code>内部维护了几个属性:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BufferPoolManagerInstance实例数</span></span><br><span class="line"><span class="type">size_t</span> num_instances_;</span><br><span class="line"><span class="comment">// 下一个轮询的BufferPoolManagerInstance实例的index，NewPgImp接口有用到</span></span><br><span class="line"><span class="type">size_t</span> next_instance_index_;</span><br><span class="line"><span class="comment">// 每个实例的大小</span></span><br><span class="line"><span class="type">size_t</span> pool_size_;</span><br><span class="line"><span class="comment">// 每个实例的指针</span></span><br><span class="line">std::vector&lt;BufferPoolManager *&gt; instances_;</span><br></pre></td></tr></table></figure>

<p><code>ParallelBufferPoolManager</code>会将不同的<code>page_id</code>映射到不同的<code>BufferPoolManagerInstance</code>实例上进行管理，我们需要实现一个<code>GetBufferPoolManager</code>方法来完成这个映射，这里可以使用最简单的取模进行映射:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BufferPoolManager *<span class="title">ParallelBufferPoolManager::GetBufferPoolManager</span><span class="params">(<span class="type">page_id_t</span> page_id)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Get BufferPoolManager responsible for handling given page id. You can use this method in your other methods.</span></span><br><span class="line">  <span class="keyword">return</span> instances_[page_id % num_instances_];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他的接口就是调用这个方法选择对应的<code>BufferPoolManagerInstance</code>实例，调用实例上的对应接口来执行，这里就不再赘述。</p>
<p>比较特殊的是<code>NewPgImp</code>接口的实现，代码给出了注释，要求我们从一个起始位置开始进行轮询，直到某一个实例<code>NewPgImp</code>成功返回<code>page</code>指针，或者再次回到起始位置，返回null。这里我们就用到了<code>next_instance_index_</code>。<code>next_instance_index_</code>的更新也是每次+1后再与<code>num_instances_</code>取模。</p>
<p>因为这是一个并行的Buffer Pool管理器，不同的<code>page_id</code>可以分散在不同的<code>BufferPoolManagerInstance</code>上进行管理，所以只有当操作的两个页同时在一个<code>BufferPoolManagerInstance</code>中时，才会有锁竞争，<code>ParallelBufferPoolManager</code>中可以不加锁。在<code>BufferPoolManagerInstance</code>中我们也可以看到<code>AllocatePage</code>方法分配新的<code>page_id</code>时，是会有一个<code>num_instances_</code>的步长进行自增的，这里的<code>num_instances_</code>就是从<code>ParallelBufferPoolManager</code>的<code>num_instances_</code>来的，这样也保证了<code>page_id</code>的不冲突。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>经过两天的查阅资料、讨论、不断尝试，终于在Gradescope上通过了Project1的测试。</p>
<p><img src="https://images-1253386616.cos.ap-guangzhou.myqcloud.com/image-20220503002900620.png" alt="image-20220503002900620"></p>
<p>通过完成了这一个Project，把前面几讲课程的内容串起来了，不得不说对于数据库的认识又加深了，理解了Buffer Pool作为数据库管理内存的缓冲池，支撑起数据库中远大于内存容量的数据内容的工作原理。</p>
<p>在这个Project的实现中，我一是为了图方便，二是确实对应C++的内容不太熟悉，对于线程安全的保障只是简单的使用<code>std::lock_guard</code>来加解锁，这样虽然能通过评分测试，但是在实际的数据库应用中，这肯定是会带来性能隐患的，待后续来优化了。</p>
<p>其实完成之后回头看Buffer Pool的实现并没有一开始我们想象的那么复杂，尽管我们实现的只是一个简单版本的Buffer Pool，但是核心逻辑在梳理之后还是很清晰的。这其实不仅仅是因为我们实现的要求简单，还因为Project给出的代码框架有足够好的抽象和解耦，我们只需要明白每个接口的作用，梳理出Buffer Pool核心的数据流向和状态流转之后，就可以进行实现，这在系统设计层面也给我带来了不小的收获。</p>
<p>继续努力学习！</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag"># 数据库</a>
              <a href="/tags/%E5%85%AC%E5%BC%80%E8%AF%BE/" rel="tag"># 公开课</a>
              <a href="/tags/CMU-15-445/" rel="tag"># CMU 15-445</a>
          </div>

        


        
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Overview"><span class="nav-number">1.</span> <span class="nav-text">Overview</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Clock-Replacement-Policy"><span class="nav-number">2.</span> <span class="nav-text">Clock Replacement Policy</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#LRU-Replacement-Policy"><span class="nav-number">3.</span> <span class="nav-text">LRU Replacement Policy</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#bool-Victim-frame-id-t-frame-id"><span class="nav-number">3.1.</span> <span class="nav-text">bool Victim(frame_id_t *frame_id)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#void-Pin-frame-id-t-frame-id"><span class="nav-number">3.2.</span> <span class="nav-text">void Pin(frame_id_t frame_id)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#void-Unpin-frame-id-t-frame-id"><span class="nav-number">3.3.</span> <span class="nav-text">void Unpin(frame_id_t frame_id)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#size-t-Size"><span class="nav-number">3.4.</span> <span class="nav-text">size_t Size()</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Buffer-Pool-Manager-Instance"><span class="nav-number">4.</span> <span class="nav-text">Buffer Pool Manager Instance</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Page-BufferPoolManagerInstance-NewPgImp-page-id-t-page-id"><span class="nav-number">4.1.</span> <span class="nav-text">Page *BufferPoolManagerInstance::NewPgImp(page_id_t *page_id)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Page-BufferPoolManagerInstance-FetchPgImp-page-id-t-page-id"><span class="nav-number">4.2.</span> <span class="nav-text">Page *BufferPoolManagerInstance::FetchPgImp(page_id_t page_id)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#bool-BufferPoolManagerInstance-FlushPgImp-page-id-t-page-id"><span class="nav-number">4.3.</span> <span class="nav-text">bool BufferPoolManagerInstance::FlushPgImp(page_id_t page_id)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#void-BufferPoolManagerInstance-FlushAllPgsImp"><span class="nav-number">4.4.</span> <span class="nav-text">void BufferPoolManagerInstance::FlushAllPgsImp()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#bool-BufferPoolManagerInstance-DeletePgImp-page-id-t-page-id"><span class="nav-number">4.5.</span> <span class="nav-text">bool BufferPoolManagerInstance::DeletePgImp(page_id_t page_id)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#bool-BufferPoolManagerInstance-UnpinPgImp-page-id-t-page-id-bool-is-dirty"><span class="nav-number">4.6.</span> <span class="nav-text">bool BufferPoolManagerInstance::UnpinPgImp(page_id_t page_id, bool is_dirty)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Parallel-Buffer-Pool-Manager"><span class="nav-number">5.</span> <span class="nav-text">Parallel Buffer Pool Manager</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">6.</span> <span class="nav-text">总结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="kaminn"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">kaminn</p>
  <div class="site-description" itemprop="description">从来也没有什么救世主，也不靠神仙皇帝</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">1</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/kaminn" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;kaminn" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">kaminn</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
